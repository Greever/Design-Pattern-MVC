\section{WPF und MVVM-Entwurfsmuster}
Zum besseren verstehen des \ac{MVVM} wird im folgenden Abschnitt zuerst das Grundprinzip von \ac{WPF} erklärt um folgend auf das eigentliche Thema \ac{MVVM} überzugehen.
\subsection{WPF}
Mit .NET Framework 3.0 wurde \ac{WPF} als Grafikframework für Windows Anwendungen eingeführt.
Das rendern und zeichnen von Inhalten findet mittels DirectX auf der \ac{GPU} statt und ermöglicht es den
 GUI-Designern die Erstellung von optisch sehr ansehnlichen Benutzeroberflächen, bei gleichzeitig Entlastung der \ac{CPU}.
In Gegensatz zur altbekannten WinForm-API trennt die \ac{WPF} die Präsentations- und Geschäftslogik nach strengen Richtlinien.
Während die Geschäftslogik in Programmcode geschrieben ist, wird die Präsentation mittels der Auszeichnungssprache \ac{XAML} deklariert.
\ac{XAML} ist wie der Name schon impliziert an XML angelehnt (siehe \ref{Beispiel XAML}). 
Wohingegen die Idee eine Auszeichnungssprache als Metasprache für die Benutzeroberfläche zu verwenden schon von HTML bekannt ist.

\quellcode{Beispiel XAML}{Beispiel XAML}{xml}{chapter/xaml.xml}

Die wichtigsten Eigenschaften einer \ac{WPF}-Anwendung im Überblick:
\begin{itemize}
\item Design mit der Auszeichnungssprache \ac{XAML}, alternativ auch ausprogrammiert möglich.
\item Unterstützung von 2D und 3D Grafiken
\item Die Ausgabe ist vektorbasiert anstatt pixelbasiert. Daraus erfolgt eine bessere Skalierbarkeit der Bildschirmausgabe.
\item Vielfältige Datenbindungsmöglichkeiten
\item Grafikberechnungen auf der GPU anstatt \ac{CPU}
\end{itemize}
Die strikte Trennung von Oberflächengestaltung und Code ermöglicht es, dass Programmentwickler und Oberflächendesigner vollkommen unabhängig voneinander Code und Benutzeroberfläche entwickeln können.

\subsection{MVVM}
Das \ac{MVVM} Entwurfsmuster wurde von John Gossman als Variante des \ac{MVP} Entwurfsmuster auf seinem Blog vorgestellt.
Hintergrund war die fortschreitende Entwicklung moderner Benutzerinterface-Frameworks, wie \ac{WPF} und Silverlight von Microsoft.
In besonders großen Anwendungen ist das \ac{MVVM} sinnvoll, in kleiner Anwendungen, ist es aufgrund des Overheads nicht wirklich zu empfehlen.
Die Abkürzung \ac{MVVM} steht wie bei \ac{MVC} und \ac{MVP} für die Komponenten des Entwurfsmusters (Siehe Abbildung \ref{MVVM-Entwurfsmuster}\label{Entwurfsmuster}).
Die Langform Model View ViewModel ist auf den ersten Blick ungewöhnlich und bedarf der Erklärung.
\begin{itemize}
\item Model: Datenzugriffsschicht für die Inhalte, dem Benutzer angezeigt und von ihm manipuliert werden. 
Dazu benachrichtigt es über Datenänderungen und führt eine Validierung der vom Benutzer übergebenen Daten durch. Hierdurch wird vor allem in der View der Code-Behind minimiert.
\item View: Alle durch die GUI angezeigten Elemente. Es bindet sich an Eigenschaften des ViewModel, um Inhalte darzustellen und zu manipulieren sowie Benutzereingaben weiterzuleiten. 
Durch die Datenbindung ist die View einfach austauschbar und ihr Code-Behind gering.
\item ViewModel: beinhaltet die UI-Logik (Model der View) und dient als Bindeglied zwischen View und obigem Model. 
Einerseits tauscht es Information mit dem Model aus, ruft also Methoden oder Dienste auf. Andererseits stellt es der View öffentliche Eigenschaften und Befehle zur Verfügung. 
Diese werden von der View an Steuerelemente gebunden, um Inhalte auszugeben bzw. UI-Ereignisse weiterzuleiten. Insgesamt wird CRUD ermöglicht. Das ViewModel darf dabei keinerlei Kenntnis der View besitzen.
\end{itemize}
Die vom \ac{MVVM} genutzte funktionale Trennung und Datenbindung des \ac{MVC} wird dazu genutzt, die bereits beschriebene lose Kopplung zu erreichen.
Diese ist jedoch im \ac{MVVM} um einiges stärker verwirklicht als in \ac{MVC} und \ac{MVP}. 
Ein Vorteil des \ac{MVVM} in der Entwicklung von Anwendungen ist zudem die bessere Einbindung der UI-Logik in Unit Tests.
Aufgrund der Tatsache, dass Sie beim \ac{MVVM} die Logik und das Command in der ViewModel-Klasse haben möchten, haben sich bei diesem Entwurfsmuster Commands wie das ActionCommand gegenüber den RoutedCommands durchgesetzt.
Ein ActionCommand erlaubt beim Instanziieren direkt die Angabe eines Delegates, der auf eine Methode im ViewModel zeigen kann.
\ac{MVVM} in Verbindung mit \ac{WPF} verwendet üblicherweise eine Implementierung mit Delegates basierend auf ICommand-Interfaces. 
\bild{0.5}{MVVM.png}{MVVM-Entwurfsmuster}{MVVM-Entwurfsmuster}

\section{Problem}





\section{Lösung}
Eine bessere Trennung der Schichten ermöglicht größere Flexibilität  
\section{Konsequenz}

\section{Beispiel}