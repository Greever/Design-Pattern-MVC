\section{WPF und MVVM-Entwurfsmuster}
\subsection{WPF}
Mit .NET Framework 3.0 wurde WPF als Programmierschnittstelle für Windows Anwendungen eingeführt.
Das rendern und zeichnen von von Inhalten basiert auf DirectX. 
Entwickler und GUI-Designern können damit ansehnliche Benutzeroberflächen erstellen.
In Gegensatz zur altbekannten WinForm-API trennt die WPF die Präsentations- und Geschäftslogik nach strengen Richtlinien, die auf der Auszeichnungssprache XAML basiert.
XAML ist wie der Name schon impliziert an XML angelehnt und ist in der Syntax sehr ähnlich.

Die wichtigsten Eigenschaften einer WPF-Anwendung im Überblick:
\begin{itemize}
\item Design mit der Auszeichnungssprache XAML, alternativ auch Ausprogrammiert möglich.
\item Unterstützung von 2D und 3D Grafiken
\item Die Ausgabe ist vektorbasiert anstatt pixelbasiert. Daraus erfolgt eine bessere Skalierbarkeit der Bildschirmausgabe.
\item Vielfältige Datenbindungsmöglichkeiten
\item Grafikberechnungen auf der GPU anstatt CPU
\end{itemize}
Die strikte Trennung von Oberflächengestaltung und Code ermöglicht es, dass Programmentwickler und Oberflächendesigner vollkommen unabhängig voneinander Code und Benutzeroberfläche entwickeln können.

\subsection{MVVM}
Es wurde bei Microsoft von John Gossman als Variante des MVP Entwurfsmuster auf seinem Blog vorgestellt.
Hintergrund war die Entwicklung moderner UIs, wie der WPF und Silverlight jeweils von Microsoft, mit seinen neuen Möglichkeiten zur Erstellung von Benutzeroberflächen.
Es gibt viele Vorteile durch das Pattern, allerdings erhöht es auch die Komplexität einer Anwendung. 
In besonders großen Anwendungen ist das MVVM sinnvoll, in kleiner Anwendungen, ist es aufgrund des Overheads nicht wirklich zu empfehlen.
Die Abkürzung MVVM steht wie bei MVC und MVP für die Komponenten des Entwurfsmusters (Siehe Abbildung \ref{MVVM-Entwurfsmuster}\label{Entwurfsmuster}).
Die Langform Model View ViewModel ist auf den ersten Blick ungewöhnlich und bedarf der Erklärung.
\begin{itemize}
\item Model: Datenzugriffsschicht für die Inhalte, dem Benutzer angezeigt und von ihm manipuliert werden. 
Dazu benachrichtigt es über Datenänderungen und führt eine Validierung der vom Benutzer übergebenen Daten durch. Hierdurch wird vor allem in der View der Code-Behind minimiert.
\item View: Alle durch die GUI angezeigten Elemente. Es bindet sich an Eigenschaften des ViewModel, um Inhalte darzustellen und zu manipulieren sowie Benutzereingaben weiterzuleiten. 
Durch die Datenbindung ist die View einfach austauschbar und ihr Code-Behind gering.
\item ViewModel: beinhaltet die UI-Logik (Model der View) und dient als Bindeglied zwischen View und obigem Model. 
Einerseits tauscht es Information mit dem Model aus, ruft also Methoden oder Dienste auf. Andererseits stellt es der View öffentliche Eigenschaften und Befehle zur Verfügung. 
Diese werden von der View an Steuerelemente gebunden, um Inhalte auszugeben bzw. UI-Ereignisse weiterzuleiten. Insgesamt wird CRUD ermöglicht. Das ViewModel darf dabei keinerlei Kenntnis der View besitzen.
\end{itemize}
Die vom MVVM genutzte funktionale Trennung und Datenbindung des MVC wird dazu genutzt, die bereits beschriebene lose Kopplung zu erreichen.
Diese ist jedoch im MVVM um einiges stärker verwirklicht als in MVC und MVP. 
Ein Vorteil des MVVM in der Entwicklung von Anwendungen ist zudem die bessere Einbindung der UI-Logik in Unit Tests.
Aufgrund der Tatsache, dass Sie beim MVVM die Logik und das Command in der ViewModel-Klasse haben möchten, haben sich bei diesem Entwurfsmuster Commands wie das ActionCommand gegenüber den RoutedCommands durchgesetzt.
Ein ActionCommand erlaubt beim Instanziieren direkt die Angabe eines Delegates, der auf eine Methode im ViewModel zeigen kann.
MVVM in Verbindung mit WPF verwendet üblicherweise eine Implementierung mit Delegates basierend auf ICommand-Interfaces. 
\bild{0.5}{MVVM.png}{MVVM-Entwurfsmuster}{MVVM-Entwurfsmuster}

\section{Problem}





\section{Lösung}
Eine bessere Trennung der Schichten ermöglicht größere Flexibilität  
\section{Konsequenz}

\section{Beispiel}