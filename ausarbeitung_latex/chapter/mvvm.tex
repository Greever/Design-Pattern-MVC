Während die Ursprünge des \ac{MVC}-Entwurfsmusters in den 1980er Jahren liegen und das \ac{MVP}-Entwurfsmuster erst in den 1990 Jahren zum ersten Mal beschrieben wurde,
ist das \ac{MVVM} noch relativ jungen Alters.
Das MVVM ist zudem anders als die beiden anderen Entwurfsmuster das spezifischste Muster, denn während MVC und MVP relativ geringe Voraussetzungen für ihre Verwendung haben,
ist MVVM speziell für morderne Technologien konzipiert. So setzt die Verwendung des MVVM den Einsatz von Microsofts \ac{WPF} oder Silverlight zwar nicht unbedingt voraus, ist aber ratsam.
Trotz dieser Einschränkung, ist es kein Fehler sich mit diesen Muster zu beschäftigen, schließlich werden mittlerweile ein Großteil aller Benutzeroberflächen, die auf .NET-Framework basieren damit erstellt.

\newpage

\section{Erklärung}
So wie das MVP eine Weiterentwicklung des MVC ist, ist das MVVM eine Weiterentwicklung des MVP-Entwursmusters.
Das Ziel dabei ist eine vollständige Entkopplung der View von der Logik.

\subsection{Model}
Das Model hat die selbe Aufgaben wie im MVC und MVP:
Datenzugriffsschicht für die Inhalte, dem Benutzer angezeigt und von ihm manipuliert werden. 
Dazu benachrichtigt es über Datenänderungen und führt eine Validierung der vom Benutzer übergebenen Daten durch. Hierdurch wird vor allem in der View der Code-Behind minimiert.

\subsection{ViewModel}
Das ViewModel ist laut Martin Fowler praktisch dem Presenter im MVP gleichzusetzen.
Es beinhaltet die UI-Logik (Model der View) und dient als Bindeglied zwischen View und obigem Model. 
Einerseits tauscht es Information mit dem Model aus, ruft also Methoden oder Dienste auf. Andererseits stellt es der View öffentliche Eigenschaften und Befehle zur Verfügung. 
Diese werden von der View an Steuerelemente gebunden, um Inhalte auszugeben bzw. UI-Ereignisse weiterzuleiten. Insgesamt wird CRUD ermöglicht. Das ViewModel darf dabei keinerlei Kenntnis der View besitzen.

\subsection{View}
Die View ist wie im MVC und MVP für Bereitstellung des Benutzeroberfläche zuständig.
Außerdem gilt im MVVM-Entwurfsmuster: 
Es bindet sich an Eigenschaften des ViewModel, um Inhalte darzustellen und zu manipulieren sowie Benutzereingaben weiterzuleiten. 
Dieses sogennante Binding ermöglicht die Austauschbarkeit der View. Der Codebehind kann ebenfalls gering gehalten werden.
\newline
\ 
\newline
Die View muss einzig per Binding an bestimmte Properties des ViewModels gebunden sein.
In Abbildung \ref{mvvmA} sind die Schichten des MVVM-Entwufsmusters schematisch dargestellt.

\bild{0.6}{mvvmschema.png}{Die Schichten des MVVM-Entwufsmusters}{mvvmA}
\ 
\newline

\newpage

\section{Problem}
Bei der Erstellung einfacher Anwendungen reicht es oftmals eine Benutzeroberfläche zu erstellen, die für alle Auslieferungen gleich sind und für immer gleich bleiben wird.
Ein Beispiel hierfür ist der bekannte Taschenrechner, der bei wahrscheinlich jeder Windowsanwendung mitgeliefert wird, siehe Abbildung \ref{calc}.
\bild{0.5}{calc.png}{Windows-Taschenrechner als Beispiel einer gleichbleibenden Benut-zeroberfläche}{calc}
\newline
\ 
\newline
Jedoch ist die Welt bekanntlich nicht immer so einfach wie bei obigen Beispiel. 
Benutzeroberflächen sind oftmals die ersten Komponenten einer Anwendung, die den Missgefallen des Endkunden erlangen.
Grund hierfür ist das allgemeine Desinteresse und meist sogar Unvermögen von Softwareentwicklern optisch reizvolle Benutzeroberflächen zu entwickeln.
Dies ist sicherlich verständlich, schließlich hat ein Entwickler genug andere Baustellen um seine Anwendung zum Laufen zu bringen.
Es macht daher Sinn, die Designarbeit an den für Design begabten Designer auszulagern. 
Jedoch versteht dieser in der Regel nicht, was dem Entwickler besonders liegt.
Eine Möglichkeit dem Standarddesigner ohne Programmierkenntnisse die Entwicklung der Benutzeroberfläche zu ermöglichen, ohne den Entwickler damit zu "'belästigen"' ist daher nötig.
Hierfür ist jedoch eine Entkopplung der UI-Logik, die dem Entwickler obliegen muss von dem Design der Nutzeroberfläche nötig.


\newpage


\section{Lösung mit MVVM und WPF}
Eine Lösung des Problems kann durch den Einsatz des MVVM-Entwurfsmusters in Verbindung mit WPF von Microsoft erreicht werden.
Bei der \ac{WPF} handelt es sich um ein auf dem .NET-Framework von Microsoft basierenden GUI-Framework, als moderne alternative zu Winforms. 
Mehr zu WPF am Ende des Abschnittes.
In Abbildung \ref{mvvm} sind die Schichten des MVVM in Verbindung mit der WPF dargestellt.

\bild{0.6}{MVVM.png}{Die Schichten des MVVM-Entwufsmusters in Verbindung mit der WPF}{mvvm}
\subsection{Databinding}

Um MVVM und die WPF auszureizen wird sog. DataBinding verwendet. Hierbei wird
die gewünschte Eigenschaft der View an die entsprechende Eigenschaft des ViewModels “gebunden“,
wobei Änderungen auf der einen Seite auch auf der anderen Seite sichtbar werden (Abb. \ref{datcont}.
Dafür wird im ViewModel das Interface INotifyPropertyChanged implementiert welches ein
PropertyChangedEvent werfen kann sobald sich der Wert einer Eigenschaft ändert. Dadurch
bekommt die View mit wenn sich am ViewModel etwas ändert. Das DataBinding kann dabei
die Werte OneTime, OneWay, TwoWay annehmen, wobei meist letzteres zum Einsatz kommt
um Änderungen an der Oberfläche wieder an das ViewModel zurückzugeben. Im Projekt erbt
jedes ViewModel von einer Basisklasse welche diese und andere für die Oberfläche nützliche
Eigenschaften schon bereitstellt. In Lising \ref{binding} ist das Einbinden eines PropertyChangedEventHandler in C\# zu sehen.
\quellcode{Binding mittels PropertyChangedEventHandler im ViewModel}{binding}{c}{chapter/ViewModel.cs}
\bild{0.6}{binding.png}{Schema des Binding des DataContext an Properties der Viewmodel}{datcont}
\subsection{Commandkonzept}
Moderne Benutzeroberflächen bieten meist verschiedene Möglichkeiten, eine Operation durchzuführen.
Wenn Sie beispielsweise in Microsoft Word ein vorhandenes Dokument öffnen wollen, können Sie entweder die Menükombination Datei \/Öffnen oder die
entsprechende Toolbar-Schaltfläche anwählen. Um eine vergleichbare Funktionalität in einer Windows Form-Anwendung umzusetzen, müssen zwei separate Event-Handler für das Click-Ereignis des Menüs und der Toolbar-Schaltfläche implementiert werden.
\newline
\ 
\newline
Beim Command-Konzept wurd nun versucht, die Abhängigkeit von grafischen Elementen und den zugehörigen Event-Handler zu entkoppeln. Zudem kann man die Steuerelemente, wie Menüs und Toolbar-Schaltflächen, deklarativ mit Commands verknüpfen.
Hierbei vermeidet man Abhängigkeiten zwischen Darstellungselementen und Code-Behind-Methoden, da letztere nur an die Commands gebunden werden müssen. In Abbildung \ref{EventsCommands} sind beide Konzepte schematisch dargestellt.
Zu beachten ist hierbei die Entkoppelung beim Command-Konzept im Vergleich zum Event-Konzept

\bild{0.9}{EventsCommands.png}{Vergleich Events und Commands}{EventsCommands}
Listing \ref{command} zeigt eine Klasse, die das Interface ICommand einbezieht und ActionCommands definiert.
\quellcode{Erstellung von Actioncommand}{command}{c}{chapter/command.cs}

\subsection{XAML}
Ein weiterer Vorteil moderner Guikonzepte wie der WPF sind die Verwendung von Deklarationssprachen zur Beschreibung der Benutzeroberflächen.
In WPF wird die View standardmäßig mittels der Deklarationssprache \ac{XAML} erstellt. Diese ist wie der Name bereits impliziert an XML angelehnt.
Der Designer der Benutzeroberfläche kann somit alleine mit der Kenntnis von XAML eine View designen und benötigt keine Programmierkenntnisse.
In Listing \ref{BeispielXAML} ist der XAML-Code eines einfachen Formulars mit zwei Ausgabefeldern und zwei Steuerbuttons zu sehen. 
In Abbildung \ref{BeispielXAMLbild} ist die Ausgabe dazu zu sehen.
\quellcode{Beispielcode einer einfachen auf XAML basierenden Benutzeroberfläche}{BeispielXAML}{xml}{chapter/xaml.xml}
\bild{0.5}{AusgabeXML.png}{Beispiel einer mittels XAML erstellten Benutzeroberfläche}{BeispielXAMLbild}
\subsection{Allgemeine Eigenschaften der WPF}
Um das Kapitel abzurunden sollen weitere Eigenschaften einer \ac{WPF}-Anwendung im Überblick aufgelistet sein:
\begin{itemize}
\item Design mit der Auszeichnungssprache \ac{XAML}, alternativ auch ausprogrammiert möglich.
\item Unterstützung von 2D und 3D Grafiken
\item Die Ausgabe ist vektorbasiert anstatt pixelbasiert. Daraus erfolgt eine bessere Skalierbarkeit der Bildschirmausgabe.
\item Vielfältige Datenbindungsmöglichkeiten
\item Einsatz des DirectX Bibliothek
\item Rendern und Grafikberechnung auf der GPU anstatt \ac{CPU}
\end{itemize}
Um in die Materia WPF und MVVM tiefer einzudringen sind folgende Bücher zu empfehlen: \cite{hube12}, \cite{schw2008mic} und \cite{geir12}.
\newline
Nützliche Software zur Erstellung eines optisch hervorragenden Benutzeroberfläche ist neben dem im Visual Studio mitgelieferten Designer auch die von Microsoft angebotene Blend Express, das standardmäßig ab Visual Studio 2012 Express ebenfalls mit ausgeliefert wird.
\newpage

\section{Fazit}
Das Binding bewirkt eine starke Entkopplung von View und ViewModel, die durch die Verwendung des Commandkonzepts im Vergleich zum Eventkonzept weiter verstärkt wird.
Eine gewisse Modularität wird durch die strikte Trennung von UI und UI-Logik bewirkt, als Folge davon steigt die Wartbarkeit der Anwendung.
Durch Einsatz von XAML ist die Trennung von Benutzeroberflächendesignern und Entwickeln sehr gut umgesetzt und hat sich bewährt.
Da die UI-Logik sich im ViewModel befindet, ist sie sehr gut testbar.
Die Konsequenz der Entkoppelung von View und ViewModel ist jedoch auch eine Erhöhung der Komplexität des Entwurfsmusters.
Dieser Overhead macht das MVVM nicht für jede Anwendung sinnvoll. Gründe für den Einsatz von MVVM:
\begin{itemize}
\item Trennung von Entwickler- und Designarbeit
\item viele unterschiedliche Benutzeroberflächen werden nötig
\item Einsatz von WPF oder Silverlight
\item gute Testbarkeit der UI-Logik nötig
\item Datacontext möglich
\end{itemize}
Gründe gegen den Einsatz von MVVM:
\begin{itemize}
\item nur in Windows lauffähig (bei Einsatz der WPF)
\item Entwicklung einer kleinen Anwendung
\item kein Datacontext möglich
\item kein Einsatz von WPF oder Silverlight möglich
\end{itemize}
Meine persönliche Meinung zu MVVM, besonders in Verbindung mit der WPF ist auf Grund der starken Entkopplung insgesamt positiv.
Die oben genannte Problemstellung kann mit MVVM und WPF vernünftig gelöst werden.